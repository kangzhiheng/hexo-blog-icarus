---
title: TCP/IP之知识点梳理
toc: true
recommend: 1
keywords: TCP/IP
date: 2020-02-15 01:48:13
thumbnail: https://pic.downk.cc/item/5e887c67504f4bcb04eed6ef.png
tags:
    - TCP/IP
    - 面试
    - 后端
categories: 
    - Linux
    - Web
---

网络原理

<!-- more -->

1. **简单介绍一下TCP三次握手。**

   ![三次握手](https://pic.downk.cc/item/5e7f8cc4504f4bcb04bdb33f.png)

   TCP协议是一个面向连接的服务，具有可靠性的保证，主要体现在TCP建立时的三次握手过程。具体过程如下，客户端A想要跟服务器B通信（`SYN`为同步位，`ACK`为确认位，`ack`为确认号，`ACK`和`ack`要同时出现，`seq`为序列号）：

   - **第一次握手**：此时**服务器端B**处于**LISTEN状态**，客户端A向主机端B发送**连接请求报文段**，即

     `SYN=1`，`seq=x(随机)`

     注意`seq`是32位（4个字节），此时客户端进入**SYN_SENT状态**；

   - **第二次握手**：服务器端B收到信号后，为该TCP分配**缓存和变量**，并向客户端A发送**确认报文段**，允许连接，即

     `SYN=1`，`ACK=1`，`seq=y(随机)`,`ack=x+1`（x包括x之前的数据都接收到了，现在期待下一次报文段发送的第一个字节是x+1）

     此时服务器端进入**SYN_RECV状态**；

   - **第三次握手**：客户端为该TCP分配**缓存和变量**，并向服务器端发送确认的确认包，可以携带数据，即

     ``SYN=0`，`ACK=1`，`seq=x+1`，`ack=y+1`

     此时客户端和服务器端都进入**ESTAB-LISTEN状态**；

   三次握手连接完毕，可以发送数据了。

2. TCP三次握手，客户端和服务器端都为TCP分配了**缓存和变量**，会产生**SYN洪泛攻击**的现象。

   - **SYN洪泛攻击**：攻击者在第一次握手时，发送`SYN`包，服务器会返回`ACK`包，此时攻击者不进行确认，这个TCP连接处于**挂起状态**，也就是**半连接状态**。攻击者不断重复这些操作，造成服务器大量的资源浪费，消耗CPU和内存。
   - **解决方法**：**SYN cookie**

3. **简单介绍一下TCP释放过程（四次挥手）**

   ![四次挥手](https://pic.downk.cc/item/5e7f8cda504f4bcb04bdbff1.png)

   参与一条TCP连接的两个进程都可以终止该连接，连接结束后，主机中的资源（缓存和变量）都会被释放。

   假设客户端想要停止通信，此时客户端和服务器端都处于**ESTAB-LISTEN状态**。`FIN`为结束位，

   - **第一次挥手**：客户端发送**连接释放报文段**，停止发送数据，主动关闭TCP连接，**连接释放报文段**包括：

     `FIN=1`，`seq=u`

     此时客户端进入**FIN-WAIT-1状态**；

   - **第二次挥手**：服务端回送一个**确认报文段**，客户端到服务器端这个方向的连接就释放了，次数处于半连接状态，**确认报文段**包括：

     `ACK=1`，`seq=v`，`ack=u+1`

     此时如果服务器端还单方向上与客户端进行**数据传送**，则处于**CLOSE-WAIT**状态。

   - **第三次挥手**：客户端接受到服务器的**确认报文段**后，也不用予以回复，因为客户端单方面结束通话了，进入**FIN_WAIT-2状态**。服务器端发完数据后，就发出**连接释放报文段**，主动关闭TCP连接。**连接释放报文段**包括：

     `FIN=1`，`ACK=1`，`seq=w`，`ack=u+1`

     注意到第二次挥手和第三次挥手里的`ack`报文段都是u+1，是因为服务端期望客户端下一次发送来的数据首部是u+1，但是客户端已经关闭连接了，所以第二次挥手和第三次挥手里的`ack`报文段不变。

     此时服务器端处于**LAST-ACK状态**。

   - **第四次挥手**：客户端回复一个**确认报文段**，即

     `ACK=1`，`seq=u+1`，`ack=w+1`

     服务器进入**CLOSED状态**。但是客户端并不会在发送确认报文段之后立即进入关闭状态，而是进入**TIME-WAIT状态**，大约是2MSL（报文最大生存周期），才会进入**CLOSED状态**。

     **等待2MSL的原因**：

     如果服务器没有收到第四次握手发的**确认报文端**，那么客户端就一直收不到服务器端的**连接释放报文段**，服务器就会一直发送，进入不了关闭状态。

4. **怎么才能认为TCP要开始建立连接了**？

   控制位除了`SYN=1`，其它位都是0。

5. **TCP建立连接需要三次握手，两次可以吗？**

   答：防止已经失效的连接出现在本次连接中。

6. **TCP可靠性**

   **检验和**、**序列号**、**确认应答**、**重发控制**、连接管理和窗口机制实现可靠性传输；

7. **URL输入到浏览器后发生了什么？**

   - DNS域名解析
   - 建立TCP连接
   - 发送HTTP请求
   - 服务器处理请求并返回HTTP报文
   - 浏览器解析渲染界面                                                                                            
   - 连接结束

8. **TCP滑动窗口**

    **滑动窗口**概念不仅存在于**数据链路层**，也存在于**传输层** 。

9. **网络IO模型**

   **知识梳理**：

   IO（Input/Output，输入输出）是计算机体系中重要的一部分。

   **两种操作**：**同步IO**和**异步IO**。

   - **同步IO**：必须等待IO操作完成后，控制权蔡返回给用户进程；
   - **异步IO**：无需等待IO操作完成，就将控制权返回给用户进程；

   **4种网络IO模型**：

   - **阻塞IO模型**：阻塞是指IO操作需要彻底完成后才返回到用户空间；
   - **非阻塞IO模型**：被调用后立即返回给用户一个状态值，不需要等待IO操作彻底完成；
   - **多路IO复用模型**：
   - **异步IO模型**：

10. **epoll与select区别：**

   - **select的句柄数目受限**，在linux/posix_types.h头文件有这样的声明：#define __FD_SETSIZE  1024 表示select最多同时监听1024个fd（文件描述符）。而epoll没有，它的限制是最大的打开文件句柄数目；
   -  **epoll的最大好处是不会随着FD的数目增长而降低效率**，在selec中采用轮询处理，其中的数据结构类似一个数组的数据结构，而epoll是维护一个队列，直接看队列是不是空就可以了。  

- 

查看协议

```bash
cat /etc/services
```

查询及设置网卡参数的命令

```bash
ifconfig     // 命令被用于配置和显示Linux内核中网络接口的网络参数，显示网络接口
ethtool em0  // em0为服务器接口
```

windows查看任务列表

```bash
tasklist
```

查看端口号和协议

```bash
netstat -nt
```

查看服务器哪些程序是监听状态

```bash
ss -ntul
```

标记为为大写`ACK`，小写`ack`为确认号

超时重传相关的两个参数：

1. 查看低层IP接管TCP最少执行的重传次数：

```bash
cat /proc/sys/net/ipv4/tcp_retries1
```

2. 连接放弃前TCP最多执行的重传次数：

   ```bash
   cat /proc/sys/net/ipv4/tcp_retries2
   ```

`ping`命令

```bash	
ping www.baidu.com -s 65507    // 65507表示包，包越大，网络的负载越大，看看是否丢包，判断一个网络的稳定性
// ping默认是发一个包，回一个包
```

DOS攻击

```bash
ping IPaddress -s 65507 -f     // 暴力发包，尽CPU所能向对方发包，而不等待回应
```

ICIP协议 ——> ping命令

`ARP`基于信任机制，谁回应就信任谁

```bash
arp -n    // IP地址与MAC地址相对应
```

